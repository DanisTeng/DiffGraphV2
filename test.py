from wrapped_function import *
from t1005_graph import *
from cpp_functions import CppFunction
from cpp_library import BuiltInLibrary
from wrapped_function import *
from sympy_function import SymPyFunction

_my_visual_studio_project_root = ""
UserLibrary.set_global_project_root(_my_visual_studio_project_root)


def test_case_1():
    """
    Normal case of generating c++ library using Diff Graph V2.

    result:
    1, generated/radius.h
    2, generated/radius.cpp
    :return:
    """
    g = Graph()
    # Declare input
    x, y = g.state_inputs(['x0', 'y_1'], 'double')
    c = g.config_inputs(['c'], 'UserType')

    # math
    radius = x ** 2 + y ** 3

    # rename critical variables [Optional]
    radius.set_name('r')

    # Conduct code generation
    wrapped = wrap_graph(graph=g,
                            input_variables=[c, x, y],
                            output_variables=[radius],
                            function_name="Radius")
    wrapped.dump_to_lib(library=UserLibrary("generated", "radius"),
                           namespace=["test", "name_sp"])


def test_case_2():
    """
    Normal case of generating "DiffGraphV2-Compatible" c++ header file.
    (User will then implement the function in source file using c++)

    result:
    1, generated/my_function.h
    :return:
    """
    # Fill out the interface of the function.
    # For derivatives not declared, they will be taken as always being zero.
    # view class AllOptions to see all supported_options.
    header = Header.create_header(function_name="MyCppFunction",
                                  inputs="Table t, double x0, double y_1",
                                  outputs="double z, double q",
                                  derivatives="D_q_D_x0,D2_z_D_x0_D_y_1,D_q_D_y_1=2",
                                  supported_options=["d0", "d1", "d2"])

    # Conduct code generation
    # dependencies will be shown in .h file for user defined types.
    header.dump_to_h_file(user_library=UserLibrary("generated", "my_function"),
                          namespace=["test"],
                          dependencies={UserLibrary("generated", "radius"),
                                        UserLibrary("whatever/lib/you", "say"),
                                        BuiltInLibrary("<memory>")})


def test_case_3():
    """
    Show how to make use of existing c++ library in graph
    (Either directly generated by Diff Graph V2 (test_case_1), or
    implemented by user with "DiffGraphV2-Compatible" header (test_case_2))

    result:
    1, generated/radius_inv.h
    2, generated/radius_inv.cpp
    :return:
    """
    g = Graph()
    # Declare input
    x, y = g.state_inputs(['x', 'y'], 'double')
    c = g.config_inputs(['c'], 'UserType')

    # Declare an existing cpp function.
    # Note that python script WON'T check that the cpp files really exist.
    radius_func = CppFunction(
        # Following code can be copied from generated/radius.h (test_case_1)
        header=Header.create_header(function_name="Radius",
                                    inputs="UserType c,"
                                           "double x,"
                                           "double y",
                                    outputs="double out_r",
                                    derivatives="D_out_r_D_x,"
                                                "D_out_r_D_y,"
                                                "D2_out_r_D_y_D_y,"
                                                "D2_out_r_D_x_D_x = 2.000000",
                                    supported_options=['d0', 'd1', 'd2']),
        namespace="test::name_sp",
        user_library=UserLibrary("generated", "radius"), )

    # math
    radius = radius_func(c, x, y)
    radius_inv = 1.0 / radius

    # rename critical variables [Optional].
    radius.set_name('r')
    radius_inv.set_name("r_inv")

    # Conduct code generation
    wrapped = wrap_graph(graph=g,
                         input_variables=[c, x, y],
                         output_variables=[radius_inv],
                         function_name="RadiusInv")
    wrapped.dump_to_lib(library=UserLibrary("generated", "radius_inv"))


def test_case_4():
    """
    If you want some PURE sympy thing:
    DiffGraphV2 may also be helpful.

    result:
    1, generated/my_sympy_function.h
    2, generated/my_sympy_function.cpp
    :return:
    """

    # Make a numerically defined function like this:
    # a,b,c,d are sympy variables.
    def my_sympy_function(a, b, c, d):
        w1 = a+b
        w2 = w1/c
        w3 = (w2**2)/(a+d)
        w4 = c * sp.log(a)
        return w3, w4

    # Wrap it as a graph function.
    sp_func_in_graph = SymPyFunction(my_sympy_function)

    # Use it in graph
    g = Graph()
    # Declare input
    a, b, c, d = g.state_inputs(['a', 'b', 'c', 'd'], 'double')

    # Call sympy function
    w3, w4 = sp_func_in_graph(a, b, c, d)

    # rename critical variables [Optional].
    w3.set_name("w3")
    w4.set_name("w4")

    # Conduct code generation
    wrapped = wrap_graph(graph=g,
                         input_variables=[a, b, c, d],
                         output_variables=[w3, w4],
                         function_name="MySympyFunction")
    wrapped.dump_to_lib(library=UserLibrary("generated", "my_sympy_function"))


def test_case_5():
    """
    A UT that can validate the generated code will be very helpful.

    :return:
    """



if __name__ == "__main__":
    test_case_1()
    test_case_2()
    test_case_3()
    test_case_4()

# TODO(): test validity in C++ project. operators. Bp process for gradients. (single output)
